#!/bin/bash
#
# dhclient-script: Network interface configuration script run by
#                  dhclient based on DHCP client communication
#
# Copyright (C) 2008-2014  Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author(s): David Cantrell <dcantrell@redhat.com>
#            Jiri Popelka <jpopelka@redhat.com>
#
# ----------
# This script is a rewrite/reworking on dhclient-script originally
# included as part of dhcp-970306:
# dhclient-script for Linux. Dan Halbert, March, 1997.
# Updated for Linux 2.[12] by Brian J. Murrell, January 1999.
# Modified by David Cantrell <dcantrell@redhat.com> for Fedora and RHEL
# ----------
#

PATH=/bin:/usr/bin:/sbin

LOGFACILITY="local7"
LOGLEVEL="notice"

logmessage() {
    msg="${1}"
    logger -p ${LOGFACILITY}.${LOGLEVEL} -t "NET" "dhclient: ${msg}"
}

quad2num() {
    if [ $# -eq 4 ]; then
        let n="${1} << 24 | ${2} << 16 | ${3} << 8 | ${4}"
        echo "${n}"
        return 0
    else
        echo "0"
        return 1
    fi
}

ip2num() {
    IFS="." quad2num ${1}
}

num2ip() {
    let n="${1}"
    let o1="(n >> 24) & 0xff"
    let o2="(n >> 16) & 0xff"
    let o3="(n >> 8) & 0xff"
    let o4="n & 0xff"
    echo "${o1}.${o2}.${o3}.${o4}"
}

get_network_address() {
# get network address for the given IP address and (netmask or prefix)
    ip="${1}"
    nm="${2}"

    if [ -n "${ip}" -a -n "${nm}" ]; then
        IFS=. read -r i1 i2 i3 i4 <<< "${ip}"
        IFS=. read -r m1 m2 m3 m4 <<< "${nm}"
        printf "%d.%d.%d.%d" "$((i1 & m1))" "$((i2 & m2))" "$((i3 & m3))" "$((i4 & m4))"
    fi
}

get_prefix() {
# get prefix for the given netmask
# http://www.linuxquestions.org/questions/programming-9/bash-cidr-calculator-646701/#post4949739
    local nbits dec
    local -a octets=( [255]=8 [254]=7 [252]=6 [248]=5 [240]=4
                      [224]=3 [192]=2 [128]=1 [0]=0           )
    
    while read -rd '.' dec; do
        [[ -z ${octets[dec]} ]] && echo "Error: $dec is not recognised" && exit 1
        (( nbits += octets[dec] ))
        (( dec < 255 )) && break
    done <<<"${1}."

    echo "$nbits"
}

class_bits() {
    let ip=$(IFS='.' ip2num $1)
    let bits=32
    let mask='255'
    for ((i=0; i <= 3; i++, 'mask<<=8')); do
        let v='ip&mask'
        if [ "$v" -eq 0 ] ; then
             let bits-=8
        else
             break
        fi
    done
    echo $bits
}

is_router_reachable() {
    # handle DHCP servers that give us a router not on our subnet
    router="${1}"
    routersubnet="$(get_network_address ${router} ${new_subnet_mask})"
    mysubnet="$(get_network_address ${new_ip_address} ${new_subnet_mask})"

    if [ ! "${routersubnet}" = "${mysubnet}" ]; then
        # TODO: This function should not have side effects such as adding or
        # removing routes. Can this be done with "ip route get" or similar
        # instead? Are there cases that rely on this route being created here?
        ip -4 route replace ${router}/32 dev ${interface}
        if [ "$?" -ne 0 ]; then
            logmessage "failed to create host route for ${router}"
            return 1
        fi
    fi

    return 0
}

add_default_gateway() {
    router="${1}"

    if is_router_reachable ${router} ; then
        metric=""
        if [ $# -gt 1 ] && [ ${2} -gt 0 ]; then
            metric="metric ${2}"
        fi
        ip -4 route replace default via ${router} dev ${interface} ${metric}
        if [ $? -ne 0 ]; then
            logmessage "failed to create default route: ${router} dev ${interface} ${metric}"
            return 1
        else
            return 0
        fi
    fi

    return 1
}

flush_dev() {
# Instead of bringing the interface down (#574568)
# explicitly clear ARP cache and flush all addresses & routes.
    ip -4 addr flush dev ${1} >/dev/null 2>&1
    ip -4 route flush dev ${1} >/dev/null 2>&1
    ip -4 neigh flush dev ${1} >/dev/null 2>&1
}

remove_old_addr() {
    if [ -n "${old_ip_address}" ]; then
        if [ -n "${old_prefix}" ]; then
            ip -4 addr del ${old_ip_address}/${old_prefix} dev ${interface} >/dev/null 2>&1
        else
            ip -4 addr del ${old_ip_address} dev ${interface} >/dev/null 2>&1
        fi
    fi
}

dhconfig() {
    if [ -n "${old_ip_address}" ] && [ -n "${alias_ip_address}" ] &&
       [ ! "${alias_ip_address}" = "${old_ip_address}" ]; then
        # possible new alias, remove old alias first
        ip -4 addr del ${old_ip_address} dev ${interface} label ${interface}:0
    fi

    if [ -n "${old_ip_address}" ] &&
       [ ! "${old_ip_address}" = "${new_ip_address}" ]; then
        # IP address changed. Delete all routes, and clear the ARP cache.
        ip -4 addr del ${old_ip_address} dev ${interface}
        ip -4 neigh flush dev ${1} >/dev/null 2>&1
    fi

    echo REASON ${reason} new_ip ${new_ip_address}

    if [ "${reason}" = "BOUND" ] || [ "${reason}" = "REBOOT" ] ||
       [ ! "${old_ip_address}" = "${new_ip_address}" ] ||
       [ ! "${old_subnet_mask}" = "${new_subnet_mask}" ] ||
       [ ! "${old_network_number}" = "${new_network_number}" ] ||
       [ ! "${old_broadcast_address}" = "${new_broadcast_address}" ] ||
       [ ! "${old_routers}" = "${new_routers}" ] ||
       [ ! "${old_interface_mtu}" = "${new_interface_mtu}" ]; then
        ip -4 addr add ${new_ip_address}/${new_prefix} broadcast ${new_broadcast_address} dev ${interface} \
           valid_lft ${new_dhcp_lease_time} preferred_lft ${new_dhcp_lease_time} >/dev/null 2>&1
        ip link set dev ${interface} up

        # The 576 MTU is only used for X.25 and dialup connections
        # where the admin wants low latency.  Such a low MTU can cause
        # problems with UDP traffic, among other things.  As such,
        # disallow MTUs from 576 and below by default, so that broken
        # MTUs are ignored, but higher stuff is allowed (1492, 1500, etc).
        if [ -n "${new_interface_mtu}" ] && [ ${new_interface_mtu} -gt 576 ]; then
            ip link set dev ${interface} mtu ${new_interface_mtu}
        fi

        # gateways
        metric="${METRIC:-}"
        let i="${METRIC:-0}"
        default_routers=()

        for router in ${new_routers} ; do
            added_router=-

            for r in ${default_routers[@]} ; do
                if [ "${r}" = "${router}" ]; then
                    added_router=1
                fi
            done

            if [ -z "${router}" ] ||
               [ "${added_router}" = "1" ] ||
               [ $(IFS=. ip2num ${router}) -le 0 ] ||
               [[ ( "${router}" = "${new_broadcast_address}" ) &&
                  ( "${new_subnet_mask}" != "255.255.255.255" ) ]]; then
                continue
            fi

            default_routers=(${default_routers[@]} ${router})
            add_default_gateway ${router} ${metric}
            let i=i+1
            metric=${i}
        done

    else # RENEW||REBIND - only update address lifetimes
        ip -4 addr change ${new_ip_address}/${new_prefix} broadcast ${new_broadcast_address} dev ${interface} \
           valid_lft ${new_dhcp_lease_time} preferred_lft ${new_dhcp_lease_time} >/dev/null 2>&1
    fi

    if [ ! "${new_ip_address}" = "${alias_ip_address}" ] &&
       [ -n "${alias_ip_address}" ]; then
        # Reset the alias address (fix: this should really only do this on changes)
        ip -4 addr flush dev ${interface} label ${interface}:0 >/dev/null 2>&1
        ip -4 addr add ${alias_ip_address}/${alias_prefix} broadcast ${alias_broadcast_address} dev ${interface} label ${interface}:0
        ip -4 route replace ${alias_ip_address}/32 dev ${interface}
    fi
}

# Section 18.1.8. (Receipt of Reply Messages) of RFC 3315 says:
# The client SHOULD perform duplicate address detection on each of
# the addresses in any IAs it receives in the Reply message before
# using that address for traffic.
add_ipv6_addr_with_DAD() {
            ip -6 addr add ${new_ip6_address}/${new_ip6_prefixlen} \
                dev ${interface} scope global valid_lft ${new_max_life} \
                                          preferred_lft ${new_preferred_life}

            # repeatedly test whether newly added address passed
            # duplicate address detection (DAD)
            for i in $(seq 5); do
                sleep 1 # give the DAD some time

                addr=$(ip -6 addr show dev ${interface} \
                       | grep ${new_ip6_address}/${new_ip6_prefixlen})

                # tentative flag == DAD is still not complete
                tentative=$(echo "${addr}" | grep tentative)
                # dadfailed flag == address is already in use somewhere else
                dadfailed=$(echo "${addr}" | grep dadfailed)

                if [ -n "${dadfailed}" ] ; then
                    # address was added with valid_lft/preferred_lft 'forever', remove it
                    ip -6 addr del ${new_ip6_address}/${new_ip6_prefixlen} dev ${interface}
                    exit 3
                fi
                if [ -z "${tentative}" ] ; then
                    if [ -n "${addr}" ]; then
                        # DAD is over
                        return 0
                    else
                        # address was auto-removed (or not added at all)
                        exit 3
                    fi
                fi
            done
            return 0
}

dh6config() {
    if [ -n "${old_ip6_prefix}" ] ||
       [ -n "${new_ip6_prefix}" ]; then
        echo Prefix ${reason} old=${old_ip6_prefix} new=${new_ip6_prefix}
        exit 0
    fi

    case "${reason}" in
        BOUND6)
            if [ -z "${new_ip6_address}" ] ||
               [ -z "${new_ip6_prefixlen}" ]; then
                exit 2
            fi

            add_ipv6_addr_with_DAD
            ;;

        RENEW6|REBIND6)
            if [[ -n "${new_ip6_address}" ]] &&
               [[ -n "${new_ip6_prefixlen}" ]]; then
               if [[  ! "${new_ip6_address}" = "${old_ip6_address}" ]]; then
                   [[ -n "${old_ip6_address}" ]] && ip -6 addr del ${old_ip6_address} dev ${interface}
                   add_ipv6_addr_with_DAD
               else # only update address lifetimes
                   ip -6 addr change ${new_ip6_address}/${new_ip6_prefixlen} \
                      dev ${interface} scope global valid_lft ${new_max_life} \
                                                preferred_lft ${new_preferred_life}
               fi
            fi
            ;;

        DEPREF6)
            if [ -z "${new_ip6_prefixlen}" ]; then
                exit 2
            fi

            ip -6 addr change ${new_ip6_address}/${new_ip6_prefixlen} \
                dev ${interface} scope global preferred_lft 0
            ;;
    esac
}


#
# ### MAIN
#

new_prefix="$(get_prefix ${new_subnet_mask})"
old_prefix="$(get_prefix ${old_subnet_mask})"
alias_prefix="$(get_prefix ${alias_subnet_mask})"

case "${reason}" in
    MEDIUM|ARPCHECK|ARPSEND)
        # Do nothing
        exit 0
        ;;

    PREINIT)
        if [ -n "${alias_ip_address}" ]; then
            # Flush alias, its routes will disappear too.
            ip -4 addr flush dev ${interface} label ${interface}:0 >/dev/null 2>&1
        fi

        # upstream dhclient-script removes (ifconfig $interface 0 up) old adresses in PREINIT,
        # but we sometimes (#125298) need (for iSCSI/nfs root to have a dhcp interface) to keep the existing ip
        # flush_dev ${interface}
        ip link set dev ${interface} up

        exit 0
        ;;

    PREINIT6)
        # ensure interface is up
        ip link set dev ${interface} up

        # remove any stale addresses from aborted clients
        ip -6 addr flush dev ${interface} scope global permanent

        # we need a link-local address to be ready (not tentative)
        for i in $(seq 50); do
            linklocal=$(ip -6 addr show dev ${interface} scope link)
            # tentative flag means DAD is still not complete
            tentative=$(echo "${linklocal}" | grep tentative)
            [[ -n "${linklocal}" && -z "${tentative}" ]] && exit 0
            sleep 0.1
        done

        exit 0
        ;;

    BOUND|RENEW|REBIND|REBOOT)
        if [ -z "${interface}" ] || [ -z "${new_ip_address}" ]; then
            exit 2
        fi
        if arping -D -q -c2 -I ${interface} ${new_ip_address}; then
            dhconfig
            exit 0
        else  # DAD failed, i.e. address is already in use
            ARP_REPLY=$(arping -D -c2 -I ${interface} ${new_ip_address} | grep reply | awk '{print toupper($5)}' | cut -d "[" -f2 | cut -d "]" -f1)
            OUR_MACS=$(ip link show | grep link | awk '{print toupper($2)}' | uniq)
            if [[ "${OUR_MACS}" = *"${ARP_REPLY}"* ]]; then
                # the reply can come from our system, that's OK (#1116004#c33)
                dhconfig
                exit 0
            else
                exit 1
            fi
        fi
        ;;

    BOUND6|RENEW6|REBIND6|DEPREF6)
        dh6config
        exit 0
        ;;

    EXPIRE6|RELEASE6|STOP6)
        if [ -z "${old_ip6_address}" ] || [ -z "${old_ip6_prefixlen}" ]; then
            exit 2
        fi

        ip -6 addr del ${old_ip6_address}/${old_ip6_prefixlen} \
            dev ${interface}

        exit 0
        ;;

    EXPIRE|FAIL|RELEASE|STOP)
        if [ -n "${alias_ip_address}" ]; then
            # Flush alias
            ip -4 addr flush dev ${interface} label ${interface}:0 >/dev/null 2>&1
        fi

        # upstream script sets interface down here,
        # we only remove old ip address
        #flush_dev ${interface}
        remove_old_addr

        if [ -n "${alias_ip_address}" ]; then
            ip -4 addr add ${alias_ip_address}/${alias_prefix} broadcast ${alias_broadcast_address} dev ${interface} label ${interface}:0
            ip -4 route replace ${alias_ip_address}/32 dev ${interface}
        fi

        exit 0
        ;;

    TIMEOUT)
        if [ -n "${new_routers}" ]; then
            if [ -n "${alias_ip_address}" ]; then
                ip -4 addr flush dev ${interface} label ${interface}:0 >/dev/null 2>&1
            fi

            ip -4 addr add ${new_ip_address}/${new_prefix} \
                broadcast ${new_broadcast_address} dev ${interface} \
                valid_lft ${new_dhcp_lease_time} preferred_lft ${new_dhcp_lease_time}
            set ${new_routers}

            if ping -q -c 1 -w 10 -I ${interface} ${1}; then
                dhconfig
                exit 0
            fi

            #flush_dev ${interface}
            remove_old_addr
            exit 1
        else
            exit 1
        fi
        ;;

    *)
        logmessage "unhandled state: ${reason}"
        exit 1
        ;;
esac

exit 0

